@ operator overloading
> making arithmetic operations possible on user defined objects/entities.
> The objects can then be added, multiplied etc.

@ conversion
> used defined types can be converted to primitive types, and vice versa.
We need to tell the compiler how to do that.

@ methods for conversion
> conversion operator OR
> 1 arg constructor

@ pitfalls for conversion
> they ought to have similar meanings, overloaded + must not do multiplication and likewise.
> if a + is overloaded, one can -without being wrong- assume += would also do the same. It's is good to cover the spots.
> the purpose to overload should be there,
for ex: finding a certain character in string, we should not overload && or any other operator for any un-intuitive purpose because the reason to bring operator overloading in picture is to make code more intuitive.

@ catch 
> using conversion operator and 1arg constructor at the same time ?
compiler doesn't like to be confused, it will throw error.
So, keep only one way for conversion.

@ not all operators can be overloaded
> :  
> ::
> .
> ->
> ?:

@ creativity
> only existing operators are overloaded, 
a thought to make up a *&, would be too creative for C++.

